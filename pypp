#!/bin/env python3

# Грамматика для @ifdef, @ifndef:
# S -> line S
# S -> @if D S
# S -> /-
# D -> @endif
# D -> line D
# D -> @ifdef D D
# D -> @ifndef D D
# D -> @else E
# E -> line E
# E -> @endif
# E -> @ifdef D E

import sys
import re
import argparse


class FileReader:
    
    def __init__(self, file):
        self.file = file
        self.file_stack = []
        
    def push(self, file):
        self.file_stack.append(self.file)
        self.file = file

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            try:
                return next(self.file)
            except StopIteration:
                try:
                    self.file = self.file_stack.pop()
                except IndexError:
                    raise StopIteration
                except StopIteration:
                    pass


class PyppContext:

    def __init__(self):
        self.definition = {}
        self.path = ["."]

    def define(self, name, value):
        pass

    def add_path(self, path):
        if path is not None:
            self.path.extend(path.split(";"))


class Directive:

    def __init__(self, input_line):
        self.line = input_line

    def subst(self):
        pass

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        raise ValueError


class IncludeDirective(Directive):

    __regex__ = re.compile("^\s*%include\s<(.+)>\s*$")

    def __init__(self, input_line):
        match_line = self.__regex__.match(input_line)
        if match_line:
            super().__init__(match_line.group(1))
        else:
            raise ValueError

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        print(f">>>include {self.line}<<<", file=pypp_output_file)


class LineDirective(Directive):

    def __init__(self, input_line):
        super().__init__(input_line)

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        print(f"{self.line}", end='', file=pypp_output_file)


#define_directive = re.compile("^\s*@define\s([^\s]+)(.*)$")
#undef_directive = re.compile("^\s*@undef\s([^\s]+)\s*$")
#ifdef_directive = re.compile("^\s*@ifdef\s([^\s]+)\s*$")
#ifundef_directive = re.compile("^\s*@ifundef\s([^\s]+)\s*$")
#end_directive = re.compile("^\s*@end\s*$")
directives = [
    IncludeDirective,
]


def ident_line(line):
    for pypp_directive in directives:
        try:
            return pypp_directive(line)
        except ValueError:
            pass

    return LineDirective(line)
    

parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input-file", type=str, help="input file name")
parser.add_argument("-oi", "--output-file", type=str, help="output file name")
parser.add_argument("-p", "--include-path", type=str, help="search path for include")
args = parser.parse_args()

if args.input_file is None:
    input_file = sys.stdin
else:
    input_file = open(args.input_file, "r", encoding="utf-8")
if args.output_file is None:
    output_file = sys.stdout
else:
    output_file = open(args.output_file, "w", encoding="utf-8")
context = PyppContext()
context.add_path(args.include_path)

input_file = FileReader(input_file)
for line in input_file:
    # чтение строки.
    # распознание директив.
    # подстановка переменных.
    # выполение директив/вывод строки.
    directive = ident_line(line)
    directive.subst()
    directive.run(input_file, context, output_file)
    

# S - правило вывода.
def pypp_flat():
    pass


# D - правило вывода.
def pypp_condition():
    pass


# E - правило вывода.
def pypp_else():
    pass
