#!/bin/env python3
import sys
import re
import argparse
from os.path import isfile, join
from collections import OrderedDict


class FileReader:
    
    def __init__(self, file):
        self.file = file
        self.file_stack = []
        
    def push(self, file):
        self.file_stack.append(self.file)
        self.file = file

    def __iter__(self):
        return self

    def __next__(self):
        while True:
            try:
                return next(self.file)
            except StopIteration:
                try:
                    self.file = self.file_stack.pop()
                except IndexError:
                    raise StopIteration
                except StopIteration:
                    pass

    def readline(self):
        try:
            return next(self)
        except StopIteration:
            return ""


class PyppContext:

    def __init__(self):
        self.definition = OrderedDict()
        self.path = ["."]
        self.switch = 0

    def define(self, name, value):
        self.definition[name] = value

    def add_path(self, path):
        if path is not None:
            self.path.extend(path.split(";"))


class Directive:

    __regex__ = re.compile(r"")

    def __init__(self, input_line):
        self.line = input_line

    def subst(self, pypp_context):
        for var_def in pypp_context.definition.keys():
            self.line = self.line.replace(var_def, pypp_context.definition[var_def])

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        raise ValueError(f"Error directive: {self.line}")

    @classmethod
    def check(cls, input_line):
        match_line = cls.__regex__.match(input_line)
        if match_line:
            return True
        else:
            return False


class FlatDirective(Directive):
    pass


class IncludeDirective(FlatDirective):

    __regex__ = re.compile(r"^\s*%include\s.*$")
    __value__ = re.compile(r"^\s*%include\s<(.+)>\s*$")

    def __init__(self, input_line):
        match_line = self.__value__.match(input_line)
        if match_line:
            super().__init__(match_line.group(1))
        else:
            raise ValueError(f"Error in %include: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            return

        # подстановка.
        self.subst(pypp_context)

        # поиск и открытие файла.
        file_name = None
        if isfile(self.line):
            file_name = self.line
        else:
            for path in pypp_context.path:
                test_file_name = join(path, self.line)
                if isfile(test_file_name):
                    file_name = test_file_name

        if file_name is None:
            raise FileNotFoundError(f"<{self.line}>")

        # отправить файл в обработку.
        pypp_input_file.push(open(file_name, "r", encoding="ascii", errors="surrogateescape"))


class DefineDirective(FlatDirective):

    __regex__ = re.compile(r"^\s*%define\s.*$")
    __value__ = re.compile(r"^\s*%define\s+([^\d][^\s]*)\s*(.*)$")

    def __init__(self, input_line):
        match_line = self.__value__.match(input_line)
        if match_line:
            variable = match_line.group(1)
            value = match_line.group(2)
            self.variable = variable
            super().__init__(value)
        else:
            raise ValueError(f"Error in %define: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            return

        # подстановка.
        self.subst(pypp_context)
        pypp_context.define(self.variable, self.line)


class UndefDirective(FlatDirective):

    __regex__ = re.compile(r"^\s*%undef\s+.*$")
    __value__ = re.compile(r"^\s*%undef\s+([^\d][^\s]*)\s*$")

    def __init__(self, input_line):
        match_line = self.__value__.match(input_line)
        if match_line:
            variable = match_line.group(1)
            self.variable = variable
            super().__init__("")
        else:
            raise ValueError(f"Error in %undef: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            return

        if self.variable in pypp_context.definition:
            del pypp_context.definition[self.variable]


class IfdefDirective(Directive):

    __regex__ = re.compile(r"^\s*%ifdef\s.*$")
    __value__ = re.compile(r"^\s*%ifdef\s+([^\d][^\s]*)\s*(.*)$")

    def __init__(self, input_line):
        match_line = self.__value__.match(input_line)
        if match_line:
            variable = match_line.group(1)
            self.variable = variable
            super().__init__("")
        else:
            raise ValueError(f"Error in %ifdef: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            pypp_context.switch += 1
        else:
            if self.variable not in pypp_context.definition:
                pypp_context.switch += 1


class IfndefDirective(Directive):

    __regex__ = re.compile(r"^\s*%ifndef\s.*$")
    __value__ = re.compile(r"^\s*%ifndef\s+([^\d][^\s]*)\s*(.*)$")

    def __init__(self, input_line):
        match_line = self.__value__.match(input_line)
        if match_line:
            variable = match_line.group(1)
            self.variable = variable
            super().__init__("")
        else:
            raise ValueError(f"Error in %ifndef: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            pypp_context.switch += 1
        else:
            if self.variable in pypp_context.definition:
                pypp_context.switch += 1


class EndDirective(Directive):

    __regex__ = re.compile(r"^\s*%end\s*$")

    def __init__(self, input_line):
        match_line = self.__regex__.match(input_line)
        if match_line:
            super().__init__("")
        else:
            raise ValueError(f"Error in %end: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            pypp_context.switch -= 1


class ElseDirective(Directive):

    __regex__ = re.compile(r"^\s*%else\s*$")

    def __init__(self, input_line):
        match_line = self.__regex__.match(input_line)
        if match_line:
            super().__init__("")
        else:
            raise ValueError(f"Error in %else: {input_line}")

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch == 1:
            pypp_context.switch = 0
        elif pypp_context.switch == 0:
            pypp_context.switch = 1


class LineDirective(FlatDirective):

    def __init__(self, input_line):
        super().__init__(input_line)

    def run(self, pypp_input_file, pypp_context, pypp_output_file):
        if pypp_context.switch > 0:
            return

        # подстановка.
        self.subst(pypp_context)
        print(f"{self.line}", end='', file=pypp_output_file)


directives = [
    IncludeDirective, DefineDirective, UndefDirective, IfdefDirective, IfndefDirective, EndDirective, ElseDirective
]


def ident_line(line):
    for pypp_directive in directives:
        if pypp_directive.check(line):
            return pypp_directive(line)
    return LineDirective(line)
    

parser = argparse.ArgumentParser()
parser.add_argument("-i", "--input-file", type=str, help="input file name")
parser.add_argument("-oi", "--output-file", type=str, help="output file name")
parser.add_argument("-p", "--include-path", type=str, help="search path for include")
args = parser.parse_args()


if args.input_file is None:
    input_file = sys.stdin
else:
    input_file = FileReader(open(args.input_file, "r", encoding="ascii", errors="surrogateescape"))
if args.output_file is None:
    output_file = sys.stdout
else:
    output_file = open(args.output_file, "w", encoding="ascii", errors="surrogateescape")
context = PyppContext()
context.add_path(args.include_path)


# Грамматика для @ifdef, @ifndef:
# S -> line S
# S -> @ifdef D S
# S -> @ifndef D S
# S -> /-
#
# D -> @end
# D -> line D
# D -> @ifdef D D
# D -> @ifndef D D
# D -> @else E
#
# E -> line E
# E -> @end
# E -> @ ifdef D E
# E -> @ifndef D E


# S - правило вывода.
def pypp_flat(input_file, context, output_file):

    while True:
        line = input_file.readline()

        # S -> /-
        if not line:
            return

        directive = ident_line(line)

        # S -> @ifdef D S
        # S -> @ifndef D S
        if isinstance(directive, IfdefDirective) or isinstance(directive, IfndefDirective):
            directive.run(input_file, context, output_file)
            pypp_condition(input_file, context, output_file)

        # S -> line S
        elif isinstance(directive, FlatDirective):
            directive.run(input_file, context, output_file)

        else:
            raise SyntaxError


# D - правило вывода.
def pypp_condition(input_file, context, output_file):

    while True:
        line = input_file.readline()

        if not line:
            raise SyntaxError

        directive = ident_line(line)

        # D -> @end
        if isinstance(directive, EndDirective):
            directive.run(input_file, context, output_file)
            return

        # D -> @ifdef D D
        # D -> @ifndef D D
        elif isinstance(directive, IfdefDirective) or isinstance(directive, IfndefDirective):
            directive.run(input_file, context, output_file)
            pypp_condition(input_file, context, output_file)

        # D -> @else E
        elif isinstance(directive, ElseDirective):
            directive.run(input_file, context, output_file)
            pypp_else(input_file, context, output_file)
            return

        # D -> line D
        elif isinstance(directive, FlatDirective):
            directive.run(input_file, context, output_file)

        else:
            raise SyntaxError


# E - правило вывода.
def pypp_else(input_file, context, output_file):

    while True:
        line = input_file.readline()

        if not line:
            raise SyntaxError

        directive = ident_line(line)

        # E -> @end
        if isinstance(directive, EndDirective):
            directive.run(input_file, context, output_file)
            return

        # E -> @ifdef D E
        # E -> @ifndef D E
        elif isinstance(directive, IfdefDirective) or isinstance(directive, IfndefDirective):
            directive.run(input_file, context, output_file)
            pypp_condition(input_file, context, output_file)

        # E -> line E
        elif isinstance(directive, FlatDirective):
            directive.run(input_file, context, output_file)

        else:
            raise SyntaxError


pypp_flat(input_file, context, output_file)
